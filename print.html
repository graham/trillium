<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>trillium</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="who.html"><strong aria-hidden="true">1.1.</strong> Who is behind this</a></li><li class="chapter-item expanded "><a href="conventions.html"><strong aria-hidden="true">1.2.</strong> About this document</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architectural Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_concepts.html"><strong aria-hidden="true">2.1.</strong> Core Concepts</a></li></ol></li><li class="chapter-item expanded "><a href="handlers.html"><strong aria-hidden="true">3.</strong> A tour of handler libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="handlers/router.html"><strong aria-hidden="true">3.1.</strong> Router</a></li><li class="chapter-item expanded "><a href="handlers/templates.html"><strong aria-hidden="true">3.2.</strong> Template Engines</a></li><li class="chapter-item expanded "><a href="handlers/logger.html"><strong aria-hidden="true">3.3.</strong> Logger</a></li><li class="chapter-item expanded "><a href="handlers/cookies.html"><strong aria-hidden="true">3.4.</strong> Cookies</a></li><li class="chapter-item expanded "><a href="handlers/sessions.html"><strong aria-hidden="true">3.5.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="handlers/proxy.html"><strong aria-hidden="true">3.6.</strong> Proxy</a></li><li class="chapter-item expanded "><a href="handlers/static.html"><strong aria-hidden="true">3.7.</strong> Static Files</a></li><li class="chapter-item expanded "><a href="handlers/websockets.html"><strong aria-hidden="true">3.8.</strong> Websockets</a></li></ol></li><li class="chapter-item expanded "><a href="library_patterns.html"><strong aria-hidden="true">4.</strong> Patterns for library authors</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">5.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">trillium</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Hi! Welcome to the documentation for trillium, a modular toolkit for
building async rust web applications.</p>
<h2 id="who-is-this-document-for"><a class="header" href="#who-is-this-document-for">Who is this document for?</a></h2>
<p>This document expects some familiarity with async rust. We intend to
offer a beginner level document at some point, but for now we
recommend looking at <a href="https://doc.rust-lang.org/book/">the rust book</a>
and <a href="https://rust-lang.github.io/async-book/">the async book</a>.</p>
<p>We also assume familiarity with web development in general, including
concepts and patterns in http servers and frameworks.</p>
<p>In particular, we offer comparisons to rust's
<a href="https://github.com/http-rs/tide">tide</a> and elixir's
<a href="https://www.phoenixframework.org/">phoenix</a> /
<a href="https://hexdocs.pm/plug/readme.html">plug</a>, as they serve as the
primary inspirations for trillium.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="who-is-behind-this"><a class="header" href="#who-is-behind-this">Who is behind this?</a></h1>
<p>👋 I'm <a href="https://github.com/jbr">jbr</a>. I've been working on tide,
async-h1, and http-types for the last year, and have landed a number
of exciting features in that framework such as sessions, unix socket
listeners, tls, and websockets. I've also done a bunch of work in
tide's http implementation, async-h1. Trillium is the direct product
of that experience. I am continuing to contribute to http-rs, but as
tide's design stabilizes, I am branching out in order to explore a
number of alternative designs that I have been considering for the
majority of the last year.</p>
<p>As such, some of the documentation will reference tide. I also have
substantial experience with node/express, koa, phoenix, sinatra, and
rails, and will try to incorporate references to those frameworks
where appropriate to provide touchstones.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="about-this-document"><a class="header" href="#about-this-document">About this document</a></h1>
<p>Here are some conventions in this document.</p>
<ul>
<li><code>use</code> declarations will only be listed once on the first usage of a
given type in order to keep code samples concise</li>
<li>In-line code looks like this: <code>|conn: Conn| async move { conn }</code> and
will generally not involve fully qualified paths</li>
<li>Footnotes are represented like this<sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>Informational asides look like this:
<blockquote>
<p>ℹ️ Fun fact: Facts are fun</p>
</blockquote>
</li>
<li>Advanced asides look like this
<blockquote>
<p>🧑‍🎓 The handler trait provides several other lifecycle hooks for
library authors</p>
</blockquote>
</li>
<li>Comparisons with Tide
<blockquote>
<p>🌊 Tide endpoints look like <code>|_req: Request&lt;_&gt;| async { Response::new(200) }</code> whereas Trillium handlers look like <code>|conn: Conn| async move { conn.with_status(200) }</code></p>
</blockquote>
</li>
<li>Comparisons with Plug:
<blockquote>
<p>🔌 Halting a plug looks like <code>conn |&gt; halt</code> (elixir), and the
equivalent in trillium is returning <code>conn.halt()</code></p>
</blockquote>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Footnotes can always be skipped</p>
</div>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="architectural-overview"><a class="header" href="#architectural-overview">Architectural Overview</a></h1>
<h2 id="composition-and-substitution"><a class="header" href="#composition-and-substitution">Composition and Substitution</a></h2>
<p>Trillium is published as a set of components that can be easily composed
to create web servers. One of the goals of this design is that to the
extent possible, all components be replaceable by alternatives.</p>
<h2 id="why-is-substitution-so-important"><a class="header" href="#why-is-substitution-so-important">Why is substitution so important?</a></h2>
<p>Async rust web frameworks still have a lot of exciting exploration
left in the near future. Instead of offering one solution as the best,
trillium offers a playground in which you can experiment with
alternatives. I want it to be painless to plug in an alternative
router, or a different http logger, or anything else you can imagine.</p>
<p>There are a lot of different purposes a web framework might be used
for, and the core library should not have to adapt in order for
someone to add support for each of those features.</p>
<p>Although I imagine that for each of the core components there will
only be one or two options, I think it is an essential aspect of good
software design that frameworks be modular and composable, as there
will always be tradeoffs for any given design.</p>
<h2 id="only-compile-what-you-need"><a class="header" href="#only-compile-what-you-need">Only compile what you need</a></h2>
<p>Instead of your application depending on a library with a large list
of reexported dependencies and conditionally including/excluding them
based on cargo features, trillium tries to apply rust's &quot;only pay for
what you need&quot; approach both at runtime and compile time.  In
particular, trillium avoids pulling in runtimes like tokio or
async-std except in the crates where you explicitly need those,
preferring instead to depend on small crates like <code>futures_lite</code>
wherever possible. Additionally, and in specific contrast to tide,
there is minimal default behavior. If you don't need a router, you
don't need to compile or run a router.</p>
<p>Everything is opt-in, instead of opt-out. Trillium uses small crates,
each of which declares its own dependencies.</p>
<h3 id="relation-to-tide-http-types-and-async-h1"><a class="header" href="#relation-to-tide-http-types-and-async-h1">Relation to tide, http-types, and async-h1</a></h3>
<p>Currently, trillium uses http-types for several core types, like headers,
status codes, response bodies, and the conn state type map. Trillium
sessions also shares the same session store backends as
tide. Currently, trillium reuses several types from async-h1, but does not
depend on the crate in order to avoid pulling in unnecessary
dependencies.</p>
<h3 id="relation-to-elixir-plug-and-phoenix"><a class="header" href="#relation-to-elixir-plug-and-phoenix">Relation to Elixir Plug and Phoenix</a></h3>
<p>The general architecture is directly inspired by Plug, and is intended
to be a hybrid of the best of plug and the best of tide. Eventually, I
intend to build an opinionated framework like Phoenix on top of the
components that are Trillium, but I don't expect that to happen for a
bit. I hope to keep the core feature set of trillium quite small and
focus on getting the design right and improving performance as much as
possible. </p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="two-core-concepts-handlers-and-conn"><a class="header" href="#two-core-concepts-handlers-and-conn">Two core concepts: Handlers and Conn</a></h1>
<p>The two most important concepts in trillium are the <code>Conn</code> type and the
<code>Handler</code> trait. Each <code>Conn</code> represents a single http request/response
pair.</p>
<h2 id="handlers"><a class="header" href="#handlers">Handlers</a></h2>
<p>The simplest form of a handler is any async function that takes a
<code>Conn</code> and returns that <code>Conn</code>. This example sets a <code>200 Ok</code> status
and sets a string body.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use trillium::Conn;
async fn hello_world(conn: Conn) -&gt; Conn {
    conn.ok(&quot;hello world!&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>With no further modification, we can drop this handler into a trillium
server and it will respond to http requests for us. We're using the
<a href="https://github.com/smol-rs/smol"><code>smol</code></a>-runtime based server adapter
here.</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub fn main() {
    trillium_smol::run(hello_world);
}
</code></pre></pre>
<p>We can also define this as a closure:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub fn main() {
    trillium_smol::run(|conn: trillium::Conn| async move {
        conn.ok(&quot;hello world&quot;)
    });
}
</code></pre></pre>
<p>This handler will respond to any request at localhost:8080, regardless of
path, and it will always send a <code>200 Ok</code> http status with the
specified body of <code>&quot;hello world&quot;</code>.</p>
<h2 id="conn"><a class="header" href="#conn">Conn</a></h2>
<p>Before we explore the concept of a handler further, let's take a quick
aside for <code>Conn</code>. As mentioned above, <code>Conn</code> represents both the
request and response, as well as any data your application associates
with that request-response cycle.</p>
<blockquote>
<p>🧑‍🎓 Advanced aside: Although the naming of Conn is directly
borrowed from Elixir's <a href="https://github.com/elixir-plug/plug"><code>plug</code></a>
and therefore also <a href="https://www.phoenixframework.org/"><code>Phoenix</code></a>,
it does in fact also own (in the rust sense) the singular
<code>TcpStream</code> that represents the connection with the http client, and
dropping a <code>Conn</code> will also disconnect the client as a result.</p>
</blockquote>
<p>The <a href="https://docs.trillium.rs/trillium/struct.conn">rustdocs for Conn</a>
contain the full details for all of the things you can do with a conn.</p>
<h3 id="returning-conn"><a class="header" href="#returning-conn">Returning Conn</a></h3>
<p>In general, because you'll be returning <code>Conn</code> from handlers, it
supports a chainable (fluent) interface for setting properties, like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>conn.with_status(202)
    .with_header((&quot;content-type&quot;, &quot;application/something-custom&quot;))
    .with_body(&quot;this is my custom body&quot;)
<span class="boring">}
</span></code></pre></pre>
<h3 id="accessing-http-request-properties"><a class="header" href="#accessing-http-request-properties">Accessing http request properties</a></h3>
<p>Conn also contains read-only properties like request headers, request
path, and request method, each of which have getter associated
functions.</p>
<h3 id="default-response"><a class="header" href="#default-response">Default Response</a></h3>
<p>The default response for a Conn is a 404 with no response body, so it
is always valid to return the Conn from a handler unmodified (<code>|conn: Conn| async move { conn }</code> is the simplest valid handler).</p>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>In addition to holding the request properties and accumulating the
response your application is going to send, a Conn also serves as a
data structure for any information your application needs to associate
with that request. This is especially valuable for communicating
between handlers, and most core handlers are implemented using conn
state. One important caveat to is that each Conn can only contain
exactly one of each type, so it is highly recommended that you only
store types that you define in state.</p>
<blockquote>
<p>🌊 Comparison with Tide: Tide has three different types of state:
Server state, request state, and response state. In Trillium, server
state is achieved using the
<a href="https://docs.trillium.rs/trillium/struct.state"><code>trillium::State</code></a>
handler, which holds any type that is Clone and puts a clone of it
into the state of each Conn that passes through the handler.</p>
</blockquote>
<h2 id="tuple-handlers"><a class="header" href="#tuple-handlers">Tuple Handlers</a></h2>
<p>Earlier, we discussed that we can use state to send data between
handlers and that handlers can always pass along the conn
unchanged. In order to use this, we need to introduce the notion of
tuple handlers.</p>
<p>Each handler in a tuple handler is called from left to right until the
conn is halted.</p>
<blockquote>
<p>🔌 Readers familiar with elixir plug will recognize this notion as
identical to pipelines, and that the term halt <a href="https://hexdocs.pm/plug/Plug.Conn.html#halt/1">is <del>stolen from</del>
inspired by plug</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env_logger::init();
use trillium_logger::Logger;
run((
    Logger::new(),
    |conn: Conn| async move { conn.ok(&quot;tuple!&quot;) }
));
<span class="boring">}
</span></code></pre></pre>
<p>This snippet adds a http logger to our application, so that if we
execute our application with <code>RUST_LOG=info cargo run</code> and make a
request to localhost:8000, we'll see something like <code>GET / 200 390.706µs 9bytes</code> on stdout.</p>
<h3 id="extending-conn"><a class="header" href="#extending-conn">Extending Conn</a></h3>
<p>It is a very common pattern in trillium for libraries to extend Conn in
order to provide additional functionality.  The Conn interface does
not provide support for sessions, cookies, route params, or many other
building blocks that other frameworks build into the core
types. Instead, to use sessions as an example, <code>trillium_sessions</code>
provides a <code>SessionConnExt</code> trait which provides associated functions
for Conn that offer session support. In general, handlers that put
data into conn state also will provide convenience functions for
accessing that state, and will export a <code>[Something]ConnExt</code> trait. <sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> 🧑‍🎓 see <a href="library_patterns.html">library_patterns</a> for an example of authoring one of these</p>
<h2 id="runtime-adapters"><a class="header" href="#runtime-adapters">Runtime Adapters</a></h2>
<p>Let's talk a little more about that <code>trillium_smol::run</code> line we've
been writing. Trillium itself is built on <code>futures</code> (<code>futures-lite</code>,
specifically). In order to run it, it needs an adapter to an async
runtime. There there are four of these
currently:</p>
<ul>
<li><code>trillium_async_std</code></li>
<li><code>trillium_smol</code></li>
<li><code>trillium_tokio</code></li>
<li><code>trillium_aws_lambda</code></li>
</ul>
<p>Although we've been using the smol server in these docs thus far, you
should use whichever runtime you prefer. If you expect to have a
dependency on async-std or tokio anyway, you might as well use the
server for that runtime. If you're new to async rust or don't have an
opinion, I recommend starting with trillium_smol. It is easy to switch trillium between runtimes at any point.</p>
<p>To run trillium on a different host or port, either provide a <code>HOST</code>
and/or <code>PORT</code> environment variables, or compile the specific values
into the server as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub fn main() {
    trillium_smol::config()
        .with_port(1337)
        .with_host(&quot;127.0.0.1&quot;)
        .run(|conn: trillium::Conn| async move { conn.ok(&quot;hello world&quot;) })
}
</code></pre></pre>
<h3 id="tls--https"><a class="header" href="#tls--https">TLS / HTTPS</a></h3>
<p>With the exception of aws lambda, which provides its own tls
termination at the load balancer, each of the above servers can be
combined with either rustls or native-tls.</p>
<p>Rustls:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_rustls::RustlsAcceptor;

const KEY: &amp;[u8] = include_bytes!(&quot;./key.pem&quot;);
const CERT: &amp;[u8] = include_bytes!(&quot;./cert.pem&quot;);

pub fn main() {
    env_logger::init();
    trillium_smol::config()
        .with_acceptor(RustlsAcceptor::from_pkcs8(CERT, KEY))
        .run(|conn: Conn| async move { conn.ok(&quot;ok&quot;) });
}
</code></pre></pre>
<p>Native tls:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_native_tls::NativeTlsAcceptor;

pub fn main() {
    env_logger::init();
    let acceptor = NativeTlsAcceptor::from_pkcs12(include_bytes!(&quot;./identity.p12&quot;), &quot;changeit&quot;);
    trillium_smol::config()
        .with_acceptor(acceptor)
        .run(|conn: Conn| async move { conn.ok(&quot;ok&quot;) });
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="a-tour-of-some-of-the-handlers-that-exist-today"><a class="header" href="#a-tour-of-some-of-the-handlers-that-exist-today">A tour of some of the handlers that exist today</a></h1>
<p>In order for trillium to be a usable web framework, we offer a number of
core utilities. However, it is our hope that alternative
implementations for at least some of these will exist in order to
explore the design space and accommodate different design constraints
and tradeoffs. Because not every application will need this
functionality, they are each released as distinct libraries from the
core of trillium.</p>
<ul>
<li><a href="./handlers/logger.html">Logger</a></li>
<li><a href="./handlers/cookies.html">Cookies</a></li>
<li><a href="./handlers/sessions.html">Sessions</a></li>
<li><a href="./handlers/templates.html">Template Engines</a></li>
<li><a href="./handlers/proxy.html">Proxy</a></li>
<li><a href="./handlers/static.html">Static File Serving</a></li>
<li><a href="./handlers/websockets.html">Websockets</a></li>
<li><a href="./handlers/router.html">Router</a></li>
</ul>
<h1 id="this-is-a-temporary-dump-of-a-lot-of-links-that-were-previously-in-the-readme"><a class="header" href="#this-is-a-temporary-dump-of-a-lot-of-links-that-were-previously-in-the-readme">This is a temporary dump of a lot of links that were previously in the readme</a></h1>
<ul>
<li>trillium
<ul>
<li><a href="https://docs.trillium.rs/trillium/index.html">rustdocs (main)</a></li>
</ul>
</li>
<li>testing
<ul>
<li>❗ <a href="https://docs.trillium.rs/trillium_testing/index.html">rustdocs (main)</a></li>
</ul>
</li>
<li>trillium-http
<blockquote>
<p>a lower abstraction than trillium itself, but potentially usable directly for some use cases</p>
</blockquote>
<ul>
<li><a href="https://docs.trillium.rs/trillium_http/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/http/examples/http.rs">example</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/http/examples/tokio-http.rs">tokio example</a></li>
</ul>
</li>
<li>file serving
<ul>
<li>static
<ul>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/static/examples/static.rs">example</a></li>
<li><a href="https://docs.trillium.rs/trillium_static/index.html">rustdocs (main)</a></li>
</ul>
</li>
<li>static-compiled
<ul>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/static-compiled/examples/static-compiled.rs">example</a> </li>
<li><a href="https://docs.trillium.rs/trillium_static_compiled/index.html">rustdocs (main)</a></li>
</ul>
</li>
</ul>
</li>
<li>templating
<ul>
<li>askama
<ul>
<li><a href="https://docs.trillium.rs/trillium_askama/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/askama/examples/askama.rs">example</a></li>
</ul>
</li>
<li>tera
<ul>
<li><a href="https://docs.trillium.rs/trillium_tera/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/tera/examples/tera.rs">example</a></li>
</ul>
</li>
<li>handlebars
<ul>
<li><a href="https://docs.trillium.rs/trillium_handlebars/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/handlebars/examples/handlebars.rs">example</a></li>
</ul>
</li>
</ul>
</li>
<li>http client
<ul>
<li><a href="https://docs.trillium.rs/trillium_client/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/client/examples/client.rs">example</a></li>
</ul>
</li>
<li>websockets
<ul>
<li><a href="https://docs.trillium.rs/trillium_websockets/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/websockets/examples/websockets.rs">example</a></li>
</ul>
</li>
<li>cookies
<ul>
<li><a href="https://docs.trillium.rs/trillium_cookies/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/cookies/examples/cookies.rs">example</a></li>
</ul>
</li>
<li>reverse proxy
<ul>
<li><a href="https://docs.trillium.rs/trillium_proxy/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/proxy/examples/proxy.rs">example</a></li>
</ul>
</li>
<li>sessions
<ul>
<li><a href="https://docs.trillium.rs/trillium_sessions/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/sessions/examples/sessions.rs">example</a></li>
</ul>
</li>
<li>logger
<ul>
<li><a href="https://docs.trillium.rs/trillium_logger/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/logger/examples/logger.rs">example</a></li>
</ul>
</li>
<li>Router
<ul>
<li><a href="https://docs.trillium.rs/trillium_router/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/router/examples/router.rs">example</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/router/examples/nested-router.rs">nested-router example</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/router/examples/router-with-macro.rs">router-with-macro example</a></li>
</ul>
</li>
<li>tls
<ul>
<li>rustls
<ul>
<li><a href="https://docs.trillium.rs/trillium_rustls/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/rustls/examples/rustls.rs">example</a></li>
</ul>
</li>
<li>native-tls
<ul>
<li><a href="https://docs.trillium.rs/trillium_native_tls/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/native-tls/examples/native-tls.rs">example</a></li>
</ul>
</li>
</ul>
</li>
<li>runtime support
<ul>
<li>smol
<ul>
<li><a href="https://docs.trillium.rs/trillium_smol/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/smol/examples/smol.rs">example</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/smol/examples/smol-with-config.rs">example-with-config</a></li>
</ul>
</li>
<li>aws-lambda
<ul>
<li><a href="https://docs.trillium.rs/trillium_aws_lambda/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/aws-lambda-server/examples/aws-lambda.rs">example</a></li>
</ul>
</li>
<li>tokio
<ul>
<li><a href="https://docs.trillium.rs/trillium_tokio/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/tokio/examples/tokio.rs">example</a></li>
</ul>
</li>
<li>async-std
<ul>
<li><a href="https://docs.trillium.rs/trillium_async_std/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/async-std/examples/async-std.rs">example</a></li>
</ul>
</li>
</ul>
</li>
<li>html-rewriter based on cloudflare's lol-html
<ul>
<li><a href="https://docs.trillium.rs/trillium_html_rewriter/index.html">rustdocs (main)</a></li>
<li><a href="https://github.com/trillium-rs/trillium/blob/main/html-rewriter/examples/html-rewriter.rs">html-rewriter</a> example</li>
</ul>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="router"><a class="header" href="#router">Router</a></h2>
<p>The trillium router is based on
<a href="https://github.com/jbr/routefinder">routefinder</a>. This router
supports two types of patterns: Untyped params and a single
wildcard. Named params are captured in a map-like interface. Any
handler can be mounted inside of a Router (including other Routers),
allowing entire applications to be mounted on a path, and allowing for
tuple handlers to be run on a given route. Any handler mounted inside
of a route that includes a <code>*</code> will have the url rewritten to the
contents of that star.</p>
<p>Alternative routers that are not based on routefinder are a prime
opportunity for innovation and exploration.</p>
<p>Here's a simple example of an application that responds to a request
like http://localhost:8000/greet/earth with &quot;hello earth&quot; and
http://localhost:8000/greet/mars with &quot;hello mars&quot; and responds to
http://localhost:8000 with &quot;hello everyone&quot;</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_router::{Router, RouterConnExt};

pub fn main() {
    env_logger::init();
    trillium_smol::run(
        Router::new()
            .get(&quot;/&quot;, |conn: Conn| async move { conn.ok(&quot;hello everyone&quot;) })
            .get(&quot;/hello/:planet&quot;, |conn: Conn| async move {
                let planet = conn.param(&quot;planet&quot;).unwrap();
                let response_body = format!(&quot;hello {}&quot;, planet);
                conn.ok(response_body)
            }),
    );
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="template-engines"><a class="header" href="#template-engines">Template engines</a></h2>
<p>There are currently three template engines for trillium. Although they are in no way mutually exclusive, most applications will want at most one of these.</p>
<h3 id="askama"><a class="header" href="#askama">Askama</a></h3>
<p>Askama is a jinja-based template engine that preprocesses templates at
compile time, resulting in efficient and type-safe templates that are
compiled into the application binary. We recommend this approach as a
default. Here's how it looks:</p>
<p>Given the following file in <code>(cargo root)/templates/examples/hello.html</code>,</p>
<pre><code class="language-django">Hello, {{ name }}!
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_askama::{AskamaConnExt, Template};

#[derive(Template)]
#[template(path = &quot;examples/hello.html&quot;)]
struct HelloTemplate&lt;'a&gt; {
    name: &amp;'a str,
}

fn main() {
    trillium_smol::run(|conn: Conn| async move { conn.render(HelloTemplate { name: &quot;world&quot; }) });
}
</code></pre></pre>
<h3 id="tera"><a class="header" href="#tera">Tera</a></h3>
<p>Tera offers runtime templating. Trillium's tera integration provides an interface very similar to <code>phoenix</code> or <code>rails</code>, with the notion of <code>assigns</code> being set on the conn prior to render.</p>
<p>Given the following file in the same directory as main.rs (examples in this case),</p>
<pre><code class="language-django">Hello, {{ name }}!
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_tera::{TeraConnExt, TeraHandler};

fn main() {
    trillium_smol::run((TeraHandler::new(&quot;**/*.html&quot;), |conn: Conn| async move {
        conn.assign(&quot;name&quot;, &quot;hi&quot;).render(&quot;examples/hello.html&quot;)
    }));
}
</code></pre></pre>
<h3 id="handlebars"><a class="header" href="#handlebars">Handlebars</a></h3>
<p>Handlebars also offers runtime templating. Given the following file in <code>examples/templates/hello.hbs</code>,</p>
<pre><code class="language-handlebars">hello {{name}}!
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_handlebars::{HandlebarsConnExt, HandlebarsHandler};

fn main() {
    env_logger::init();
    trillium_smol::run((
        HandlebarsHandler::new(&quot;./examples/templates/*.hbs&quot;),
        |conn: Conn| async move {
            conn.assign(&quot;name&quot;, &quot;world&quot;)
                .render(&quot;examples/templates/hello.hbs&quot;)
        },
    ));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="logger"><a class="header" href="#logger">Logger</a></h2>
<p>Currently there's just a DevLogger, but soon there will be more
loggers. Trillium loggers use the <code>log</code> crate and emit one line at the
info log level per http request/response pair. We like to use the
<code>env_logger</code> crate, but any <code>log</code> backend will work equally well.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium_logger::Logger;

pub fn main() {
    env_logger::init();
    trillium_smol::run((Logger::new(), &quot;ok&quot;));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="cookies"><a class="header" href="#cookies">Cookies</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_cookies::{cookie::Cookie, CookiesConnExt, CookiesHandler};

pub fn main() {
    env_logger::init();

    trillium_smol::run((CookiesHandler::new(), |conn: Conn| async move {
        if let Some(cookie_value) = conn.cookies().get(&quot;some_cookie&quot;) {
            println!(&quot;current cookie value: {}&quot;, cookie_value.value());
        }

        conn.with_cookie(
            Cookie::build(&quot;some_cookie&quot;, &quot;some-cookie-value&quot;)
                .path(&quot;/&quot;)
                .finish(),
        )
        .ok(&quot;ok!&quot;)
    }));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="sessions"><a class="header" href="#sessions">Sessions</a></h2>
<p>Sessions are a common convention in web frameworks, allowing for a
safe and secure way to associate server-side data with a given http
client (browser). Trillium's session storage is built on the
<code>async-session</code> crate, which allows us to share session stores with
tide. Currently, these session stores exist:</p>
<ul>
<li>MemoryStore (reexported as trillium_sessions::MemoryStore) <sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>CookieStore (reexported as trillium_sessions::CookieStore) <sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>PostgresSessionStore and SqliteSessionStore from <a href="https://github.com/jbr/async-sqlx-session">async-sqlx-session</a></li>
<li>RedisSessionStore from <a href="https://github.com/jbr/async-redis-session">async-redis-session</a></li>
<li>MongodbSessionStore from <a href="https://github.com/http-rs/async-mongodb-session">async-mongodb-session</a></li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The memory store and cookie store should be avoided for use in
production applications. The memory store will lose all session
state on server process restart, and the cookie store makes
different security tradeoffs than the database-backed stores. If
possible, use a database.</p>
</div>
<blockquote>
<p>❗The session handler <em>must</em> be used in conjunction with the cookie
handler, and it must run <em>after</em> the cookie handler. This particular
interaction is also present in other frameworks, and is due to the
fact that regardless of which session store is used, sessions use a
secure cookie as a unique identifier.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_cookies::CookiesHandler;
use trillium_sessions::{MemoryStore, SessionConnExt, SessionHandler};

pub fn main() {
    env_logger::init();

    trillium_smol::run((
        CookiesHandler::new(),
        SessionHandler::new(MemoryStore::new(), b&quot;01234567890123456789012345678901123&quot;),
        |conn: Conn| async move {
            let count: usize = conn.session().get(&quot;count&quot;).unwrap_or_default();
            conn.with_session(&quot;count&quot;, count + 1)
                .ok(format!(&quot;count: {}&quot;, count))
        },
    ));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="proxy"><a class="header" href="#proxy">Proxy</a></h1>
<p>Trillium includes a custom http client implementation in order to
support reverse proxying requests. There are two tls implementations
for this client.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium_logger::Logger;
use trillium_rustls::RustlsConnector;
use trillium_smol::TcpConnector;

type Proxy = trillium_proxy::Proxy&lt;RustlsConnector&lt;TcpConnector&gt;&gt;;

pub fn main() {
    env_logger::init();
    trillium_smol::run((Logger::new(), Proxy::new(&quot;https://httpbin.org/&quot;)));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="static-file-serving"><a class="header" href="#static-file-serving">Static file serving</a></h2>
<p>Trillium offers two rudimentary approaches to static file serving for now. Neither of these approaches perform any cache-related header checking yet.</p>
<h3 id="from-disk"><a class="header" href="#from-disk">From disk</a></h3>
<p>This handler loads content from disk at request, and does not yet do any in-memory caching.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium_static::{crate_relative_path, StaticFileHandler};

pub fn main() {
    trillium_smol::run(
        StaticFileHandler::new(crate_relative_path!(&quot;examples/files&quot;))
            .with_index_file(&quot;index.html&quot;),
    )
}
</code></pre></pre>
<h3 id="from-memory-at-compile-time"><a class="header" href="#from-memory-at-compile-time">From memory, at compile time</a></h3>
<p>This handler includes all of the static content in the compiled binary, allowing it to be shipped independently from the assets.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium_static_compiled::{include_dir, StaticCompiledHandler};
pub fn main() {
    trillium_smol::run(
        StaticCompiledHandler::new(include_dir!(&quot;./examples/files&quot;)).with_index_file(&quot;lib.rs&quot;),
    );
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="websocket-support"><a class="header" href="#websocket-support">WebSocket support</a></h2>
<p>WebSockets work a lot like tide's, since I recently wrote that
interface as well. One difference in trillium is that the websocket
connection also contains some aspects of the original http request,
such as request headers, the request path and method, and any state
that has been accumulated by previous handlers in a sequence.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use futures_util::StreamExt;
use trillium_websockets::{Message, WebSocket};

pub fn main() {
    env_logger::init();

    trillium_smol::run(WebSocket::new(|mut websocket| async move {
        while let Some(Ok(Message::Text(input))) = websocket.next().await {
            websocket
                .send_string(format!(&quot;received your message: {}&quot;, &amp;input))
                .await;
        }
    }));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="patterns-for-library-authors"><a class="header" href="#patterns-for-library-authors">Patterns for library authors</a></h1>
<h2 id="state-1"><a class="header" href="#state-1">State</a></h2>
<p>Let's take a look at an implementation of a library that incrementally counts the number of conns that pass through it and attaches the number to each conn. It would be unsafe to store a u64 directly in the state set, because other libraries might be doing so, so we wrap it with a private newtype called ConnNumber. Since this isn't accessible outside of our library, we can be sure that our handler is the only place that sets it.  We provide a ConnExt trait in order to provide access to this data.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod conn_counter {
    use std::sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    };
    use trillium::{async_trait, Conn, Handler};

    struct ConnNumber(u64);

    #[derive(Default)]
    pub struct ConnCounterHandler(Arc&lt;AtomicU64&gt;);

    impl ConnCounterHandler {
        pub fn new() -&gt; Self {
            Self::default()
        }
    }

    #[async_trait]
    impl Handler for ConnCounterHandler {
        async fn run(&amp;self, conn: Conn) -&gt; Conn {
            let number = self.0.fetch_add(1, Ordering::SeqCst);
            conn.with_state(ConnNumber(number))
        }
    }

    pub trait ConnCounterConnExt {
        fn conn_number(&amp;self) -&gt; u64;
    }

    impl ConnCounterConnExt for Conn {
        fn conn_number(&amp;self) -&gt; u64 {
            self.state::&lt;ConnNumber&gt;()
                .expect(&quot;conn_number must be called after the handler&quot;)
                .0
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And usage of the library looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use conn_counter::{ConnCounterConnExt, ConnCounterHandler};
use trillium::{Conn, Handler};

fn handler() -&gt; impl Handler {
    (ConnCounterHandler::new(), |conn: Conn| async move {
        let conn_number = conn.conn_number();
        conn.ok(format!(&quot;conn number was {}&quot;, conn_number))
    })
}

fn main() {
    trillium_smol::run(handler());
}

#[cfg(test)]
mod test {
    use trillium_testing::prelude::*;

    #[test]
    fn test_conn_counter() {
        let handler = super::handler();
        assert_ok!(get(&quot;/&quot;).on(&amp;handler), &quot;conn number was 0&quot;);
        assert_ok!(get(&quot;/&quot;).on(&amp;handler), &quot;conn number was 1&quot;);
        assert_ok!(get(&quot;/&quot;).on(&amp;handler), &quot;conn number was 2&quot;);
        assert_ok!(get(&quot;/&quot;).on(&amp;handler), &quot;conn number was 3&quot;);
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If you're excited about the ideas here, this page will be kept up to date with ways to get involved.</p>
<ol>
<li>Build stuff <em>using</em> trillium. Open source if possible, but even if not, feedback from actual deployed applications will be given higher priority than issues that aren't driven by real use cases.</li>
<li>Build new handlers for trillium. The intent of trillium's design is that as many components as possible should be replaceable. It would make me very happy to deprecate one of the components I built in preference to a more robust alternative. All trillium-compatible crates will be linked in a section of the documentation.</li>
<li>Contribute to the documentation and tests</li>
<li>File issues for bugs</li>
</ol>
<blockquote>
<p>❗Please don't file a Pull Request, regardless of how small, without prior discussion on an Issue. All PRs without an associated issue will be immediately closed. I value your time and want to make sure that any code you write is in an aligned direction.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>

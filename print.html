<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>trillium</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="who.html"><strong aria-hidden="true">1.1.</strong> Who is behind this</a></li><li class="chapter-item expanded "><a href="conventions.html"><strong aria-hidden="true">1.2.</strong> About this document</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architectural Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_concepts.html"><strong aria-hidden="true">2.1.</strong> Core Concepts</a></li></ol></li><li class="chapter-item expanded "><a href="handlers.html"><strong aria-hidden="true">3.</strong> A tour of handler libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="handlers/router.html"><strong aria-hidden="true">3.1.</strong> Router</a></li><li class="chapter-item expanded "><a href="handlers/templates.html"><strong aria-hidden="true">3.2.</strong> Template Engines</a></li><li class="chapter-item expanded "><a href="handlers/logger.html"><strong aria-hidden="true">3.3.</strong> Logger</a></li><li class="chapter-item expanded "><a href="handlers/cookies.html"><strong aria-hidden="true">3.4.</strong> Cookies</a></li><li class="chapter-item expanded "><a href="handlers/sessions.html"><strong aria-hidden="true">3.5.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="handlers/proxy.html"><strong aria-hidden="true">3.6.</strong> Proxy</a></li><li class="chapter-item expanded "><a href="handlers/static.html"><strong aria-hidden="true">3.7.</strong> Static Files</a></li><li class="chapter-item expanded "><a href="handlers/websockets.html"><strong aria-hidden="true">3.8.</strong> Websockets</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">4.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">trillium</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Hi! Welcome to the documentation for trillium, a modular toolkit for
building async rust web applications.</p>
<h2 id="who-is-this-document-for"><a class="header" href="#who-is-this-document-for">Who is this document for?</a></h2>
<p>This document expects some familiarity with async rust. We intend to
offer a beginner level document at some point, but for now we
recommend looking at <a href="https://doc.rust-lang.org/book/">the rust book</a>
and <a href="https://rust-lang.github.io/async-book/">the async book</a>.</p>
<p>We also assume familiarity with web development in general, including
concepts and patterns in http servers and frameworks.</p>
<p>In particular, we offer comparisons to rust's
<a href="https://github.com/http-rs/tide">tide</a> and elixir's
<a href="https://www.phoenixframework.org/">phoenix</a> /
<a href="https://hexdocs.pm/plug/readme.html">plug</a>, as they serve as the
primary inspirations for trillium.</p>
<h1 id="who-is-behind-this"><a class="header" href="#who-is-behind-this">Who is behind this?</a></h1>
<p>👋 I'm <a href="https://github.com/jbr">jbr</a>. I've been working on tide,
async-h1, and http-types for the last year, and have landed a number
of exciting features in that framework, such as sessions, unix socket
listeners, tls, and websockets. I've also done a bunch of work in
tide's http implementation, async-h1. Trillium is the direct product
of that experience. I am continuing to contribute to http-rs, but as
tide's design stabilizes, I am branching out in order to explore a
number of alternative designs that I have been considering for the
majority of the last year.</p>
<p>As such, some of the documentation will reference tide from tide. I
also have substantial experience with node/express, koa, phoenix,
sinatra, and rails, and will try to incorporate references to those
frameworks to provide touchstones.</p>
<h1 id="about-this-document"><a class="header" href="#about-this-document">About this document</a></h1>
<p>Here are some conventions in this document.</p>
<ul>
<li><code>use</code> declarations will only be listed once on the first usage of a given type in order to keep code samples concise</li>
<li>In-line code looks like this: <code>|conn: Conn| async move { conn }</code> and will generally not involve fully qualified paths</li>
<li>Footnotes are represented like this<sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>Informational asides look like this:
<blockquote>
<p>ℹ️ Fun fact: This is neither fun, nor a fact</p>
</blockquote>
</li>
<li>Advanced asides look like this
<blockquote>
<p>🧑‍🎓 The handler trait provides several other lifecycle hooks for library authors</p>
</blockquote>
</li>
<li>Comparisons with Tide
<blockquote>
<p>🌊 Tide endpoints look like <code>|_req: Request&lt;_&gt;| async { Response::new(200) }</code> whereas Trillium handlers look like <code>|conn: Conn| async move { conn.status(200) }</code></p>
</blockquote>
</li>
<li>Comparisons with Plug:
<blockquote>
<p>🔌 Halting a plug looks like <code>conn |&gt; halt</code> (elixir), and the equivalent in trillium is returning <code>conn.halt()</code></p>
</blockquote>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Footnotes can always be skipped</p>
</div>
<h1 id="architectural-overview"><a class="header" href="#architectural-overview">Architectural Overview</a></h1>
<h2 id="composability"><a class="header" href="#composability">Composability</a></h2>
<p>Trillium is published as a set of components that can be easily composed
to create web servers. One of the goals of this design is that to the
extent possible, all components be replaceable by alternatives.</p>
<h2 id="why-is-substitutability-so-important"><a class="header" href="#why-is-substitutability-so-important">Why is substitutability so important?</a></h2>
<p>It is the author's opinion that async rust web frameworks still have a
lot of exciting exploration left in the near future. Instead of
offering one solution as the best, trillium offers a playground in which
you can experiment with alternatives. I want it to be painless to plug
in an alternative router, or a different http logger, or anything else
you can imagine.</p>
<p>There are a lot of different purposes a web framework might be used
for, and the core library should not have to adapt in order for
someone to add support for each of those features.</p>
<p>Although I imagine that for each of the core components there will
only be one or two options, I think it is an essential aspect of good
software design that frameworks be modular and composable, as there
will always be tradeoffs for any given design.</p>
<h2 id="only-pay-for-what-you-need-without-having-to-toggle-cargo-features"><a class="header" href="#only-pay-for-what-you-need-without-having-to-toggle-cargo-features">Only pay for what you need, without having to toggle cargo features</a></h2>
<p>Instead of declaring a large list of top level dependencies and
conditionally including/excluding them based on cargo features,
trillium tries to apply rust's &quot;only pay for what you need&quot; approach
both at runtime and compile time.  In particular, we avoid pulling in
runtimes like tokio or async-std except in the crates where you
explicitly need those, preferring instead to depend on small crates
like <code>futures_lite</code> wherever possible. Additionally, and in contrast
to tide, there is zero default behavior. If you don't need a router,
you don't need to compile or run a router.</p>
<p>Everything is opt-in, instead of opt-out. We use small crates, each of
which declares its own dependencies.</p>
<h3 id="relation-to-tide-http-types-and-async-h1"><a class="header" href="#relation-to-tide-http-types-and-async-h1">Relation to tide, http-types, and async-h1</a></h3>
<p>Currently, trillium uses http-types for several core types, like headers,
status codes, response bodies, and the conn state type map. Trillium
sessions also shares the same session store backends as
tide. Currently, trillium reuses several types from async-h1, but does not
depend on the crate in order to avoid pulling in unnecessary
dependencies.</p>
<h3 id="relation-to-elixir-plug-and-phoenix"><a class="header" href="#relation-to-elixir-plug-and-phoenix">Relation to Elixir Plug and Phoenix</a></h3>
<p>The general architecture is directly inspired by Plug, and is intended
to be a hybrid of the best of plug and the best of tide. Eventually, I
hope to build an opinionated framework like Phoenix on top of the
components that are trillium, but I don't expect that to happen for a
while. I hope to keep the core feature set of trillium quite small and
focus on getting the design right and improving performance as much as
possible. </p>
<h1 id="two-core-concepts-conn-and-handlers"><a class="header" href="#two-core-concepts-conn-and-handlers">Two core concepts: Conn and Handlers</a></h1>
<p>The two most important concepts in trillium are the <code>Conn</code> type and the
<code>Handler</code> trait. Each <code>Conn</code> represents a single http request/response
pair.</p>
<h2 id="handlers"><a class="header" href="#handlers">Handlers</a></h2>
<p>The simplest form of a handler is any async function that takes a
<code>Conn</code> and returns that <code>Conn</code>. This example sets a <code>200 Ok</code> status
and sets a string body.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use trillium::Conn;
async fn hello_world(conn: Conn) -&gt; Conn {
    conn.ok(&quot;hello world!&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>With no further modification, we can drop this handler into a trillium
server and it will respond to http requests for us. We're using the
<a href="https://github.com/smol-rs/smol"><code>smol</code></a>-runtime based server adapter
here.</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub fn main() {
    trillium_smol_server::run(hello_world);
}
</code></pre></pre>
<p>We can also define this as a closure:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub fn main() {
    trillium_smol_server::run(|conn: trillium::Conn| async move {
        conn.ok(&quot;hello world&quot;)
    });
}
</code></pre></pre>
<p>This handler will respond to any request at localhost:8080, regardless of
path, and it will always send a <code>200 Ok</code> http status with the
specified body of <code>&quot;hello world&quot;</code>.</p>
<h2 id="conn"><a class="header" href="#conn">Conn</a></h2>
<p>Before we explore the concept of a handler further, let's take a quick
aside for <code>Conn</code>. As mentioned above, <code>Conn</code> represents both the
request and response, as well as any data your application associates
with that request-response cycle.</p>
<blockquote>
<p>🧑‍🎓 Advanced aside: Although the naming of Conn is directly
borrowed from Elixir's <a href="https://github.com/elixir-plug/plug"><code>plug</code></a>
and therefore also <a href="https://www.phoenixframework.org/"><code>Phoenix</code></a>,
it does in fact also own (in the rust sense) the singular
<code>TcpStream</code> that represents the connection with the http client, and
dropping a <code>Conn</code> will also disconnect the client as a result.</p>
</blockquote>
<p>🚧 TODO: Fill in rustdocs link 🚧
The rustdocs for Conn contain the full details for all of the things you can do with a conn.</p>
<h3 id="returning-conn"><a class="header" href="#returning-conn">Returning Conn</a></h3>
<p>In general, because you'll be returning <code>Conn</code> from handlers, it
supports a chainable (fluent) interface for setting properties, like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>conn.status(202)
    .send_header(&quot;content-type&quot;, &quot;application/something-custom&quot;)
    .body(&quot;this is my custom body&quot;)
<span class="boring">}
</span></code></pre></pre>
<h3 id="accessing-http-request-properties"><a class="header" href="#accessing-http-request-properties">Accessing http request properties</a></h3>
<p>Conn also contains read-only properties like request headers, request
path, and request method, each of which have getter associated
functions.</p>
<h3 id="default-response"><a class="header" href="#default-response">Default Response</a></h3>
<p>The default response for a Conn is a 404 with no response body, so it
is always valid to return the Conn from a handler unmodified (<code>|conn: Conn| async move { conn }</code> is the simplest valid handler).</p>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>In addition to holding the request properties and accumulating the
response your application is going to send, a Conn also serves as a
data structure for any information your application needs to associate
with that request. This is especially valuable for communicating
between handlers, and most core handlers are implemented using conn
state. One important caveat to is that each Conn can only contain
exactly one of each type, so it is highly recommended that you only
store types that you define in state.</p>
<blockquote>
<p>🌊 Comparison with Tide: Tide has three different types of state:
Server state, request state, and response state. In Trillium, server
state is achieved using the <code>trillium::State</code> handler, which holds any
type that is Clone and puts a clone of it into the state of each
Conn that passes through the handler.</p>
</blockquote>
<h3 id="extending-conn"><a class="header" href="#extending-conn">Extending Conn</a></h3>
<p>It is a very common pattern in trillium for libraries to extend Conn in
order to provide additional functionality.  The Conn interface does
not provide support for sessions, cookies, route params, or many other
building blocks that other frameworks build into the core
types. Instead, to use sessions as an example, <code>trillium_sessions</code>
provides a <code>SessionConnExt</code> trait which provides associated functions
for Conn that offer session support. In general, handlers that put
data into conn state also will provide convenience functions for
accessing that state, and will export a <code>[Something]ConnExt</code> trait.</p>
<h2 id="servers"><a class="header" href="#servers">Servers</a></h2>
<p>Let's talk a little more about that <code>trillium_smol_server::run</code> line we've
been writing. Trillium itself is built on <code>futures</code> (<code>futures-lite</code>,
specifically). In order to run it, it needs an adapter to an async
runtime. These adapters are called servers, and there are four of them
currently:</p>
<ul>
<li><code>trillium_async_std_server</code></li>
<li><code>trillium_smol_server</code></li>
<li><code>trillium_tokio_server</code></li>
<li><code>trillium_aws_lambda_server</code></li>
</ul>
<p>Although we've been using the smol server in these docs thus far, you
should use whichever runtime you prefer. If you expect to have a
dependency on async-std or tokio anyway, you might as well use the
server for that runtime.</p>
<p>To run trillium on a different host or port, either provide a <code>HOST</code> and/or <code>PORT</code> environment variables, or compile the specific values into the server as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub fn main() {
    trillium_smol_server::config()
        .with_port(1337)
        .with_host(&quot;127.0.0.1&quot;)
        .run(|conn: trillium::Conn| async move { conn.ok(&quot;hello world&quot;) })
}
</code></pre></pre>
<h3 id="tls--https"><a class="header" href="#tls--https">TLS / HTTPS</a></h3>
<p>With the exception of aws lambda, which provides its own tls
termination at the load balancer, each of the above servers can be
combined with either rustls or native-tls.</p>
<p>Rustls:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_rustls::RustTls;

const KEY: &amp;[u8] = include_bytes!(&quot;./key.pem&quot;);
const CERT: &amp;[u8] = include_bytes!(&quot;./cert.pem&quot;);

pub fn main() {
    env_logger::init();
    trillium_smol_server::config()
        .with_acceptor(RustTls::from_pkcs8(CERT, KEY))
        .run(|conn: Conn| async move { conn.ok(&quot;ok&quot;) });
}
</code></pre></pre>
<p>Native tls:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_native_tls::NativeTls;

pub fn main() {
    env_logger::init();
    trillium_smol_server::config()
        .with_acceptor(NativeTls::from_pkcs12(
            include_bytes!(&quot;./identity.p12&quot;),
            &quot;changeit&quot;,
        ))
        .run(|conn: Conn| async move { conn.ok(&quot;ok&quot;) });
}
</code></pre></pre>
<h2 id="sequences"><a class="header" href="#sequences">Sequences</a></h2>
<p>Earlier, we discussed that we can use state to send data between
handlers and that handlers can always pass along the conn
unchanged. In order to use this, we need to introduce the notion of
Sequences. A sequence is a <code>Vec</code> of handlers, each of which is run on
the connection until one of the handlers halts the conn.</p>
<blockquote>
<p>🔌 Readers familiar with elixir plug will recognize this notion as
identical to pipelines, and that the term halt <a href="https://hexdocs.pm/plug/Plug.Conn.html#halt/1">is <del>stolen from</del>
inspired by plug</a></p>
</blockquote>
<h3 id="building-a-sequence"><a class="header" href="#building-a-sequence">Building a Sequence</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env_logger::init();
run(trillium::Sequence::new()
    .and(trillium_logger::DevLogger)
    .and(|conn: Conn| async move { conn.ok(&quot;sequence!&quot;) }));
<span class="boring">}
</span></code></pre></pre>
<p>This snippet adds a http logger to our application, so that if we
execute our application with <code>RUST_LOG=info cargo run</code> and make a
request to localhost:8000, we'll see something like <code>GET / 200 390.706µs 9bytes</code> on stdout.</p>
<h3 id="macros-if-you-want-them"><a class="header" href="#macros-if-you-want-them">Macros, if you want them</a></h3>
<p>Because sequences are quite common in trillium, we also have a macro that
makes them even easier to build. Instead of writing
<code>Sequence::new().and(a).and(b).and(c)</code> we can write
<code>trillium::sequence![a, b, c]</code>, which makes our above example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env_logger::init();
run(trillium::sequence![
    trillium_logger::DevLogger,
    |conn: Conn| async move { conn.ok(&quot;sequence!&quot;) }
]);
<span class="boring">}
</span></code></pre></pre>
<p>Sequence is itself a handler, and as a result can be used in any place
another handler could be used.  If you need to, you can nest sequences
inside of each other.</p>
<h1 id="a-tour-of-some-of-the-handlers-that-exist-today"><a class="header" href="#a-tour-of-some-of-the-handlers-that-exist-today">A tour of some of the handlers that exist today</a></h1>
<p>In order for trillium to be a usable web framework, we offer a number of
core utilities. However, it is our hope that alternative
implementations for at least some of these will exist in order to
explore the design space and accommodate different design constraints
and tradeoffs. Because not every application will need this
functionality, they are each released as distinct libraries from the
core of trillium.</p>
<ul>
<li><a href="./handlers/logger.html">Logger</a></li>
<li><a href="./handlers/cookies.html">Cookies</a></li>
<li><a href="./handlers/sessions.html">Sessions</a></li>
<li><a href="./handlers/templates.html">Template Engines</a></li>
<li><a href="./handlers/proxy.html">Proxy</a></li>
<li><a href="./handlers/static.html">Static File Serving</a></li>
<li><a href="./handlers/websockets.html">Websockets</a></li>
<li><a href="./handlers/router.html">Router</a></li>
</ul>
<h2 id="router"><a class="header" href="#router">Router</a></h2>
<p>The trillium router is based on
<a href="https://github.com/jbr/routefinder">routefinder</a>. This router
supports two types of patterns: Untyped params and a single
wildcard. Named params are captured in a map-like interface. Any
handler can be mounted inside of a Router (including other Routers),
allowing entire applications to be mounted on a path, and allowing for
sequences to be run on a given route. Any handler mounted inside of a
route that includes a <code>*</code> will have the url rewritten to the contents
of that star.</p>
<p>Alternative routers that are not based on routefinder are a prime
opportunity for innovation and exploration.</p>
<p>Here's a simple example of an application that responds to a request
like http://localhost:8000/greet/earth with &quot;hello earth&quot; and
http://localhost:8000/greet/mars with &quot;hello mars&quot; and responds to
http://localhost:8000 with &quot;hello everyone&quot;</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_router::{Router, RouterConnExt};

pub fn main() {
    env_logger::init();
    trillium_smol_server::run(
        Router::new()
            .get(&quot;/&quot;, |conn: Conn| async move { conn.ok(&quot;hello everyone&quot;) })
            .get(&quot;/hello/:planet&quot;, |conn: Conn| async move {
                let planet = conn.param(&quot;planet&quot;).unwrap();
                let response_body = format!(&quot;hello {}&quot;, planet);
                conn.ok(response_body)
            }),
    );
}
</code></pre></pre>
<h2 id="template-engines"><a class="header" href="#template-engines">Template engines</a></h2>
<p>There are currently three template engines for trillium. Although they are in no way mutually exclusive, most applications will want at most one of these.</p>
<h3 id="askama"><a class="header" href="#askama">Askama</a></h3>
<p>Askama is a jinja-based template engine that preprocesses templates at
compile time, resulting in efficient and type-safe templates that are
compiled into the application binary. We recommend this approach as a
default. Here's how it looks:</p>
<p>Given the following file in <code>(cargo root)/templates/examples/hello.html</code>,</p>
<pre><code class="language-django">Hello, {{ name }}!
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::Conn;
use trillium_askama::{AskamaConnExt, Template};

#[derive(Template)]
#[template(path = &quot;examples/hello.html&quot;)]
struct HelloTemplate&lt;'a&gt; {
    name: &amp;'a str,
}

fn main() {
    trillium_smol_server::run(
        |conn: Conn| async move { conn.render(HelloTemplate { name: &quot;world&quot; }) },
    );
}
</code></pre></pre>
<h3 id="tera"><a class="header" href="#tera">Tera</a></h3>
<p>Tera offers runtime templating. Trillium's tera integration provides an interface very similar to <code>phoenix</code> or <code>rails</code>, with the notion of <code>assigns</code> being set on the conn prior to render.</p>
<p>Given the following file in the same directory as main.rs (examples in this case),</p>
<pre><code class="language-django">Hello, {{ name }}!
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::{sequence, Conn};
use trillium_tera::{TeraConnExt, TeraHandler};

fn main() {
    trillium_smol_server::run(sequence![
        TeraHandler::new(&quot;**/*.html&quot;),
        |conn: Conn| async move { conn.assign(&quot;name&quot;, &quot;hi&quot;).render(&quot;examples/hello.html&quot;) }
    ]);
}
</code></pre></pre>
<h3 id="handlebars"><a class="header" href="#handlebars">Handlebars</a></h3>
<p>Handlebars also offers runtime templating. Given the following file in <code>examples/templates/hello.hbs</code>,</p>
<pre><code class="language-handlebars">hello {{name}}!
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::{sequence, Conn};
use trillium_handlebars::{Handlebars, HandlebarsConnExt};

fn main() {
    env_logger::init();
    trillium_smol_server::run(sequence![
        Handlebars::new(&quot;./examples/templates/*.hbs&quot;),
        |conn: Conn| async move {
            conn.assign(&quot;name&quot;, &quot;world&quot;)
                .render(&quot;examples/templates/hello.hbs&quot;)
        }
    ]);
}
</code></pre></pre>
<h2 id="logger"><a class="header" href="#logger">Logger</a></h2>
<p>Currently there's just a DevLogger, but soon there will be more
loggers. Trillium loggers use the <code>log</code> crate and emit one line at the
info log level per http request/response pair. We like to use the
<code>env_logger</code> crate, but any <code>log</code> backend will work equally well.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::sequence;
use trillium_logger::DevLogger;

pub fn main() {
    env_logger::init();
    trillium_smol_server::run(sequence![DevLogger, &quot;ok&quot;]);
}
</code></pre></pre>
<h2 id="cookies"><a class="header" href="#cookies">Cookies</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::{sequence, Conn};
use trillium_cookies::{Cookie, Cookies, CookiesConnExt};

pub fn main() {
    env_logger::init();

    trillium_smol_server::run(sequence![Cookies, |conn: Conn| async move {
        if let Some(cookie_value) = conn.cookies().get(&quot;some_cookie&quot;) {
            println!(&quot;current cookie value: {}&quot;, cookie_value.value());
        }

        conn.ok(&quot;ok!&quot;).with_cookie(
            Cookie::build(&quot;some_cookie&quot;, &quot;some-cookie-value&quot;)
                .path(&quot;/&quot;)
                .finish(),
        )
    }]);
}
</code></pre></pre>
<h2 id="sessions"><a class="header" href="#sessions">Sessions</a></h2>
<p>Sessions are a common convention in web frameworks, allowing for a
safe and secure way to associate server-side data with a given http
client (browser). Trillium's session storage is built on the
<code>async-session</code> crate, which allows us to share session stores with
tide. Currently, these session stores exist:</p>
<ul>
<li>MemoryStore (reexported as trillium_sessions::MemoryStore) <sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>CookieStore (reexported as trillium_sessions::CookieStore) <sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>PostgresSessionStore and SqliteSessionStore from <a href="https://github.com/jbr/async-sqlx-session">async-sqlx-session</a></li>
<li>RedisSessionStore from <a href="https://github.com/jbr/async-redis-session">async-redis-session</a></li>
<li>MongodbSessionStore from <a href="https://github.com/http-rs/async-mongodb-session">async-mongodb-session</a></li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The memory store and cookie store should be avoided for use in
production applications. The memory store will lose all session
state on server process restart, and the cookie store makes
different security tradeoffs than the database-backed stores. If
possible, use a database.</p>
</div>
<blockquote>
<p>❗The session handler <em>must</em> be used in conjunction with the cookie
handler, and it must run <em>after</em> the cookie handler. This particular
interaction is also present in other frameworks, and is due to the
fact that regardless of which session store is used, sessions use a
secure cookie as a unique identifier.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium::{sequence, Conn};
use trillium_sessions::{MemoryStore, SessionConnExt, Sessions};

pub fn main() {
    env_logger::init();

    trillium_smol_server::run(sequence![
        trillium_cookies::Cookies,
        Sessions::new(MemoryStore::new(), b&quot;01234567890123456789012345678901123&quot;),
        |conn: Conn| async move {
            let count: usize = conn.session().get(&quot;count&quot;).unwrap_or_default();
            conn.with_session(&quot;count&quot;, count + 1)
                .ok(format!(&quot;count: {}&quot;, count))
        }
    ]);
}
</code></pre></pre>
<h1 id="proxy"><a class="header" href="#proxy">Proxy</a></h1>
<p>Trillium includes a custom http client implementation in order to
support reverse proxying requests. There are two tls implementations
for this client.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use async_net::TcpStream;
use trillium::sequence;
use trillium_client::Rustls;
use trillium_logger::DevLogger;
use trillium_proxy::Proxy;

pub fn main() {
    env_logger::init();
    trillium_smol_server::run(sequence![
        DevLogger,
        Proxy::&lt;Rustls&lt;TcpStream&gt;&gt;::new(&quot;https://httpbin.org/&quot;)
    ]);
}
</code></pre></pre>
<h2 id="static-file-serving"><a class="header" href="#static-file-serving">Static file serving</a></h2>
<p>Trillium offers two rudimentary approaches to static file serving for now. Neither of these approaches perform any cache-related header checking yet.</p>
<h3 id="from-disk"><a class="header" href="#from-disk">From disk</a></h3>
<p>This handler loads content from disk at request, and does not yet do any in-memory caching.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium_static::Static;

pub fn main() {
    trillium_smol_server::run(Static::new(&quot;../docs/book/&quot;).with_index_file(&quot;index.html&quot;))
}
</code></pre></pre>
<h3 id="from-memory-at-compile-time"><a class="header" href="#from-memory-at-compile-time">From memory, at compile time</a></h3>
<p>This handler includes all of the static content in the compiled binary, allowing it to be shipped independently from the assets.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use trillium_static_compiled::{include_dir, StaticCompiled};
pub fn main() {
    trillium_smol_server::run(StaticCompiled::new(include_dir!(&quot;./src&quot;)).with_index_file(&quot;lib.rs&quot;));
}
</code></pre></pre>
<h2 id="websocket-support"><a class="header" href="#websocket-support">WebSocket support</a></h2>
<p>WebSockets work a lot like tide's, since I recently wrote that
interface as well. One difference in trillium is that the websocket
connection also contains some aspects of the original http request,
such as request headers, the request path and method, and any state
that has been accumulated by previous handlers in a sequence.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use futures_util::StreamExt;
use trillium_websockets::{Message, WebSocket};

pub fn main() {
    env_logger::init();

    trillium_smol_server::run(WebSocket::new(|mut websocket| async move {
        while let Some(Ok(Message::Text(input))) = websocket.next().await {
            websocket
                .send_string(format!(&quot;received your message: {}&quot;, &amp;input))
                .await;
        }
    }));
}
</code></pre></pre>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If you're excited about the ideas here, this page will be kept up to date with ways to get involved.</p>
<ol>
<li>Build stuff <em>using</em> trillium. Open source if possible, but even if not, feedback from actual deployed applications will be given higher priority than issues that aren't driven by real use cases.</li>
<li>Build new handlers for trillium. The intent of trillium's design is that as many components as possible should be replaceable. It would make me very happy to deprecate one of the components I built in preference to a more robust alternative.</li>
<li>Contribute to the documentation and tests</li>
<li>File issues for bugs</li>
</ol>
<blockquote>
<p>❗Please don't file a Pull Request, regardless of how small, without prior discussion on an Issue. All PRs without an associated issue will be immediately closed.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
